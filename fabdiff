# param_extractor_fixed.py
import os
import re
import tkinter as tk
from tkinter import ttk, filedialog, messagebox

# 기본 함수 호출 캡처(괄호 내부)
DEFAULT_CS_PATTERN = r"GetFabOrientedUseYn\s*\((.*?)\)"
DEFAULT_JAVA_PATTERN = r"selectFabOrientedUseYn\s*\((.*?)\)"

# 안전한 인자 분리: 중첩 괄호/대괄호/중괄호와 따옴표 안의 콤마는 무시하고 토플레벨 콤마로 분리
def split_args_top_level(argstr: str):
    args = []
    cur = []
    stack = []
    i = 0
    L = len(argstr)
    while i < L:
        ch = argstr[i]
        if ch in ('"', "'"):
            quote = ch
            cur.append(ch)
            i += 1
            while i < L:
                c2 = argstr[i]
                cur.append(c2)
                if c2 == "\\":
                    # escape, include next char
                    i += 1
                    if i < L:
                        cur.append(argstr[i])
                elif c2 == quote:
                    i += 1
                    break
                i += 1
            continue
        if ch in "([{":
            stack.append(ch)
            cur.append(ch)
            i += 1
            continue
        if ch in ")]}":
            if stack:
                top = stack[-1]
                if (top == "(" and ch == ")") or (top == "[" and ch == "]") or (top == "{" and ch == "}"):
                    stack.pop()
            cur.append(ch)
            i += 1
            continue
        if ch == "," and not stack:
            args.append("".join(cur).strip())
            cur = []
            i += 1
            continue
        cur.append(ch)
        i += 1
    last = "".join(cur).strip()
    if last != "":
        args.append(last)
    return args

def strip_quotes(s: str):
    s = s.strip()
    if len(s) >= 2 and ((s[0] == '"' and s[-1] == '"') or (s[0] == "'" and s[-1] == "'")):
        return s[1:-1]
    return s

# 파일 하나에서 CS/Java 패턴 검색하고 카테고리/디프 추출
def extract_from_file(filepath, cs_re, java_re):
    out = []  # list of (filepath, type, category, diff)
    try:
        with open(filepath, "r", encoding="utf-8", errors="ignore") as f:
            text = f.read()
    except Exception:
        return out

    fname = os.path.basename(filepath)

    if fname.endswith(".designer.cs"):
        return out

    if fname.endswith(".cs"):
        for m in cs_re.finditer(text):
            inner = m.group(1)
            args = split_args_top_level(inner)
            if len(args) >= 2:
                # for CS we need last-2 = category, last-1 = diff
                if len(args) >= 2:
                    cat_raw = args[-2]
                    diff_raw = args[-1]
                    cat = strip_quotes(cat_raw)
                    diff = strip_quotes(diff_raw)
                    out.append((filepath, "cs", cat, diff))
    elif fname.endswith(".java"):
        for m in java_re.finditer(text):
            inner = m.group(1)
            args = split_args_top_level(inner)
            if len(args) >= 2:
                # for Java we need first = category, second = diff
                cat_raw = args[0]
                diff_raw = args[1]
                cat = strip_quotes(cat_raw)
                diff = strip_quotes(diff_raw)
                out.append((filepath, "java", cat, diff))

    return out

# 검색 루프(경로 리스트)
def search_paths(paths, cs_pattern, java_pattern):
    try:
        cs_re = re.compile(cs_pattern, flags=re.IGNORECASE | re.DOTALL)
    except re.error:
        cs_re = re.compile(DEFAULT_CS_PATTERN, flags=re.IGNORECASE | re.DOTALL)
    try:
        java_re = re.compile(java_pattern, flags=re.IGNORECASE | re.DOTALL)
    except re.error:
        java_re = re.compile(DEFAULT_JAVA_PATTERN, flags=re.IGNORECASE | re.DOTALL)

    aggregated = {}  # (cat,diff) -> {"cs": set(paths), "java": set(paths)}
    for base in paths:
        if not os.path.exists(base):
            continue
        if os.path.isfile(base):
            files_to_walk = [base]
        else:
            files_to_walk = []
            for root, _, files in os.walk(base):
                for fn in files:
                    files_to_walk.append(os.path.join(root, fn))
        for fp in files_to_walk:
            if not (fp.lower().endswith(".cs") or fp.lower().endswith(".java")):
                continue
            recs = extract_from_file(fp, cs_re, java_re)
            for _fp, ftype, cat, diff in recs:
                key = (cat, diff)
                if key not in aggregated:
                    aggregated[key] = {"cs": set(), "java": set()}
                aggregated[key][ftype].add(_fp)
    return aggregated

# ---------- GUI ----------
class App:
    def __init__(self, root):
        self.root = root
        root.title("Fab Param Extractor (CS/Java)")
        root.geometry("1200x800")
        root.minsize(900, 600)

        # paths input
        frm_paths = ttk.LabelFrame(root, text="검색 경로 (한 줄에 1개, 여러 줄 입력 가능)")
        frm_paths.pack(fill="x", padx=10, pady=6)
        self.txt_paths = tk.Text(frm_paths, height=4)
        self.txt_paths.pack(fill="x", padx=6, pady=6)
        btn_add = ttk.Button(frm_paths, text="경로 추가...", command=self.add_path_dialog)
        btn_add.pack(anchor="w", padx=6, pady=(0,6))

        # regex inputs
        frm_regex = ttk.LabelFrame(root, text="정규표현식 (함수명\\( ... \\) 형태 캡처)")
        frm_regex.pack(fill="x", padx=10, pady=6)
        lbl_cs = ttk.Label(frm_regex, text="C# 패턴:")
        lbl_cs.grid(row=0, column=0, sticky="w", padx=6, pady=4)
        self.ent_cs = ttk.Entry(frm_regex)
        self.ent_cs.grid(row=0, column=1, sticky="we", padx=6, pady=4)
        self.ent_cs.insert(0, DEFAULT_CS_PATTERN)
        lbl_java = ttk.Label(frm_regex, text="Java 패턴:")
        lbl_java.grid(row=1, column=0, sticky="w", padx=6, pady=4)
        self.ent_java = ttk.Entry(frm_regex)
        self.ent_java.grid(row=1, column=1, sticky="we", padx=6, pady=4)
        self.ent_java.insert(0, DEFAULT_JAVA_PATTERN)
        frm_regex.columnconfigure(1, weight=1)

        # filter & buttons
        frm_actions = ttk.Frame(root)
        frm_actions.pack(fill="x", padx=10, pady=6)
        ttk.Label(frm_actions, text="Type Filter:").pack(side="left", padx=(0,6))
        self.type_var = tk.StringVar(value="all")
        ttk.Combobox(frm_actions, values=["all", "cs", "java"], textvariable=self.type_var, width=8).pack(side="left")
        ttk.Button(frm_actions, text="검색 실행", command=self.on_search).pack(side="left", padx=8)
        ttk.Button(frm_actions, text="선택된 group 복사 (category\\tdiff)", command=self.copy_selected).pack(side="right")

        # treeview for grouped results
        frm_results = ttk.LabelFrame(root, text="검색 결과 (그룹 → 파일들)")
        frm_results.pack(fill="both", expand=True, padx=10, pady=6)
        self.tree = ttk.Treeview(frm_results)
        self.tree.pack(fill="both", expand=True, side="left")
        # scrollbars
        sb_v = ttk.Scrollbar(frm_results, orient="vertical", command=self.tree.yview)
        sb_v.pack(side="right", fill="y")
        self.tree.configure(yscrollcommand=sb_v.set)
        # columns not used (we'll use text in nodes), but configure width
        self.tree["columns"] = ("info",)
        self.tree.column("#0", width=700)
        self.tree.column("info", width=200)

        # bind ctrl+c
        root.bind_all("<Control-c>", lambda e: self.copy_selected())

        # internal
        self.aggregated = {}  # last search result

    def add_path_dialog(self):
        p = filedialog.askdirectory()
        if p:
            current = self.txt_paths.get("1.0", "end").rstrip()
            if current:
                self.txt_paths.insert("end", "\n" + p)
            else:
                self.txt_paths.insert("end", p)

    def on_search(self):
        raw = self.txt_paths.get("1.0", "end").strip()
        if not raw:
            messagebox.showwarning("경고", "검색할 경로를 한 줄 이상 입력하세요.")
            return
        paths = [r.strip() for r in raw.splitlines() if r.strip()]
        cs_pat = self.ent_cs.get().strip()
        java_pat = self.ent_java.get().strip()
        # validate regex
        try:
            re.compile(cs_pat)
            re.compile(java_pat)
        except re.error as e:
            messagebox.showerror("정규식 오류", f"정규식 컴파일 실패: {e}")
            return

        # search
        self.aggregated = search_paths(paths, cs_pat, java_pat)
        self.populate_tree()

    def populate_tree(self):
        # clear
        for iid in self.tree.get_children():
            self.tree.delete(iid)
        # build
        filter_type = self.type_var.get()
        for (cat, diff), type_map in sorted(self.aggregated.items(), key=lambda x: (x[0][0], x[0][1])):
            # count files respecting filter
            cs_files = sorted(type_map["cs"])
            java_files = sorted(type_map["java"])
            if filter_type == "cs" and not cs_files:
                continue
            if filter_type == "java" and not java_files:
                continue
            # parent label includes category/diff and total count
            total = len(cs_files) + len(java_files)
            parent_label = f"{cat} \t {diff}   ({total} files)"
            parent = self.tree.insert("", "end", text=parent_label)
            # child for cs if exist
            if cs_files:
                cs_node = self.tree.insert(parent, "end", text=f"[cs] ({len(cs_files)})")
                for idx, fp in enumerate(cs_files, start=1):
                    self.tree.insert(cs_node, "end", text=f"cs {idx}file: {fp}")
            # child for java if exist
            if java_files:
                java_node = self.tree.insert(parent, "end", text=f"[java] ({len(java_files)})")
                for idx, fp in enumerate(java_files, start=1):
                    self.tree.insert(java_node, "end", text=f"java {idx}file: {fp}")

    def copy_selected(self):
        sel = self.tree.selection()
        if not sel:
            return
        pairs = []
        seen = set()
        for iid in sel:
            # if parent selected
            parent = iid
            # climb to top-level parent (the group node)
            top = parent
            while self.tree.parent(top):
                top = self.tree.parent(top)
            # get category and diff from top node text
            top_text = self.tree.item(top, "text")
            # top_text format: "{cat} \t {diff}   ({N} files)"
            # split by tab to get cat and diff
            parts = top_text.split("\t")
            if len(parts) >= 2:
                cat = parts[0].strip()
                # diff may contain trailing " (N files)" so strip after splitting
                diff_part = parts[1].strip()
                # if diff_part contains "(", remove it and trailing
                diff = diff_part.split("(")[0].strip()
                key = (cat, diff)
                if key not in seen:
                    pairs.append(key)
                    seen.add(key)
        if not pairs:
            return
        text = "\n".join([f"{c}\t{d}" for c, d in pairs])
        try:
            self.root.clipboard_clear()
            self.root.clipboard_append(text)
            messagebox.showinfo("복사완료", "categoryCode\tdiffCode가 복사되었습니다.")
        except Exception:
            messagebox.showerror("오류", "클립보드 복사 실패")

if __name__ == "__main__":
    root = tk.Tk()
    app = App(root)
    root.mainloop()
