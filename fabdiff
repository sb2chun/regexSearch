import os
import re
import tkinter as tk
from tkinter import filedialog, ttk, messagebox
from openpyxl import Workbook

# ===== 기본 정규표현식 (원래대로) =====
DEFAULT_CS_PATTERN = r'GetFabOrientedUseYn\s*\(\s*([^,]+)\s*,\s*([^,]+)\s*,\s*([^)]+)\)'
DEFAULT_JAVA_PATTERN = r'selectFabOrientedUseYn\s*\(\s*([^,]+)\s*,\s*([^,]+)\s*,\s*([^)]+)\)'

def _findall_with_pattern(pattern_or_str, data, flags=re.IGNORECASE | re.DOTALL):
    """
    pattern_or_str: str 또는 컴파일된 re.Pattern
    data: 검색 대상 문자열
    flags: 문자열 패턴인 경우에만 사용
    """
    if hasattr(pattern_or_str, "findall"):
        # 이미 컴파일된 패턴 객체
        return pattern_or_str.findall(data)
    else:
        return re.findall(pattern_or_str, data, flags=flags)

# ===== 핵심 파싱 로직 (factory는 결과에서 제외) =====
def extract_params(file_path, cs_pattern, java_pattern):
    """
    cs_pattern / java_pattern can be either strings or compiled re.Pattern objects.
    반환: [(file_path, file_name, type, categoryCode, diffCode), ...]
    """
    results = []
    file_name = os.path.basename(file_path)

    if file_name.endswith(".designer.cs"):
        return results  # 제외

    try:
        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
            data = f.read()
    except Exception:
        return results

    if file_name.endswith(".cs"):
        matches = _findall_with_pattern(cs_pattern, data)
        # matches may be list of tuples (fac, cat, diff) or strings depending on regex
        for m in matches:
            # ensure tuple unpack
            if isinstance(m, tuple) and len(m) >= 3:
                fac, cat, diff = m[0], m[1], m[2]
            else:
                # fallback: try to extract quoted params inside the matched string
                fac = cat = diff = ""
                params = re.findall(r'"(.*?)"|\'(.*?)\'', m)
                # params is list of tuples from the alternation groups; flatten
                flat = [p[0] or p[1] for p in params]
                if len(flat) >= 3:
                    fac, cat, diff = flat[0], flat[1], flat[2]
                else:
                    continue
            results.append((
                file_path,
                file_name,
                "cs",
                str(cat).strip().strip('"').strip("'"),
                str(diff).strip().strip('"').strip("'")
            ))

    elif file_name.endswith(".java"):
        matches = _findall_with_pattern(java_pattern, data)
        for m in matches:
            if isinstance(m, tuple) and len(m) >= 3:
                cat, diff, fac = m[0], m[1], m[2]
            else:
                fac = cat = diff = ""
                params = re.findall(r'"(.*?)"|\'(.*?)\'', m)
                flat = [p[0] or p[1] for p in params]
                if len(flat) >= 3:
                    cat, diff, fac = flat[0], flat[1], flat[2]
                else:
                    continue
            results.append((
                file_path,
                file_name,
                "java",
                str(cat).strip().strip('"').strip("'"),
                str(diff).strip().strip('"').strip("'")
            ))

    return results


def search_files(paths, cs_pattern_raw, java_pattern_raw):
    """
    paths: list of path strings (files or directories)
    cs_pattern_raw, java_pattern_raw: regex strings (we'll compile them and pass compiled patterns)
    """
    collected = []
    # Try compile; if compilation fails, fallback to defaults (but inform)
    try:
        cs_compiled = re.compile(cs_pattern_raw, flags=re.IGNORECASE | re.DOTALL)
    except re.error as e:
        messagebox.showwarning("정규식 경고", f"C# 정규표현식 컴파일 실패, 기본 패턴으로 대체합니다.\n{e}")
        cs_compiled = re.compile(DEFAULT_CS_PATTERN, flags=re.IGNORECASE | re.DOTALL)

    try:
        java_compiled = re.compile(java_pattern_raw, flags=re.IGNORECASE | re.DOTALL)
    except re.error as e:
        messagebox.showwarning("정규식 경고", f"Java 정규표현식 컴파일 실패, 기본 패턴으로 대체합니다.\n{e}")
        java_compiled = re.compile(DEFAULT_JAVA_PATTERN, flags=re.IGNORECASE | re.DOTALL)

    for path in paths:
        path = path.strip()
        if not path:
            continue
        if os.path.isfile(path):
            collected += extract_params(path, cs_compiled, java_compiled)
        elif os.path.isdir(path):
            for root, dirs, files in os.walk(path):
                for file in files:
                    if file.endswith(".cs") and not file.endswith(".designer.cs"):
                        full = os.path.join(root, file)
                        collected += extract_params(full, cs_compiled, java_compiled)
                    elif file.endswith(".java"):
                        full = os.path.join(root, file)
                        collected += extract_params(full, cs_compiled, java_compiled)
    return collected


# ===== GUI 및 그룹화 로직 =====
class App:
    def __init__(self, master):
        self.master = master
        master.title("Fab Oriented UseYn 파라미터 추출기")
        master.geometry("1400x820")
        master.minsize(900, 600)

        # 경로 입력 (여러 줄)
        tk.Label(master, text="검색 경로 (한 줄에 1경로)").grid(row=0, column=0, sticky="w", padx=10, pady=4)
        self.path_text = tk.Text(master, height=4)
        self.path_text.grid(row=1, column=0, columnspan=4, sticky="we", padx=10)

        tk.Button(master, text="경로 선택", command=self.pick_path).grid(row=1, column=4, padx=6)
        tk.Button(master, text="실행", command=self.run_search).grid(row=1, column=5, padx=6)

        # 정규표현식 입력 (원래 기본값)
        tk.Label(master, text="C# Regex:").grid(row=2, column=0, sticky="w", padx=10, pady=6)
        self.cs_regex_var = tk.StringVar(value=DEFAULT_CS_PATTERN)
        self.cs_regex_entry = tk.Entry(master, textvariable=self.cs_regex_var)
        self.cs_regex_entry.grid(row=2, column=0, columnspan=6, sticky="we", padx=100)

        tk.Label(master, text="Java Regex:").grid(row=3, column=0, sticky="w", padx=10, pady=6)
        self.java_regex_var = tk.StringVar(value=DEFAULT_JAVA_PATTERN)
        self.java_regex_entry = tk.Entry(master, textvariable=self.java_regex_var)
        self.java_regex_entry.grid(row=3, column=0, columnspan=6, sticky="we", padx=100)

        # 타입 필터
        tk.Label(master, text="Type:").grid(row=4, column=0, sticky="w", padx=10, pady=6)
        self.type_filter = ttk.Combobox(master, values=["all", "cs", "java"], width=8)
        self.type_filter.set("all")
        self.type_filter.grid(row=4, column=0, padx=60, sticky="w")

        # 결과 트리 (그룹핑된 트리)
        columns = ("file_path", "file_name", "type", "categoryCode", "diffCode")
        self.tree = ttk.Treeview(master, columns=columns, show="headings", selectmode="extended")
        for col in columns:
            self.tree.heading(col, text=col)
        # 칼럼 너비
        self.tree.column("file_path", width=600, anchor="w")
        self.tree.column("file_name", width=220, anchor="w")
        self.tree.column("type", width=80, anchor="center")
        self.tree.column("categoryCode", width=200, anchor="w")
        self.tree.column("diffCode", width=200, anchor="w")

        self.tree.grid(row=5, column=0, columnspan=6, sticky="nsew", padx=10, pady=8)

        # 스크롤바
        v_scroll = ttk.Scrollbar(master, orient="vertical", command=self.tree.yview)
        h_scroll = ttk.Scrollbar(master, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=v_scroll.set, xscrollcommand=h_scroll.set)
        v_scroll.grid(row=5, column=6, sticky="ns", pady=8)
        h_scroll.grid(row=6, column=0, columnspan=6, sticky="we", padx=10)

        # 버튼들: 엑셀 저장 / 카테고리+디프 복사
        tk.Button(master, text="엑셀로 저장", command=self.save_excel).grid(row=7, column=0, pady=10, sticky="w", padx=10)
        tk.Button(master, text="카테고리+디프 복사", command=self.copy_category_diff).grid(row=7, column=1, pady=10, sticky="w")

        # Ctrl+C 바인딩 (트리에서 카테고리+디프 복사)
        self.tree.bind("<Control-c>", lambda e: self.copy_category_diff())
        self.tree.bind("<Control-C>", lambda e: self.copy_category_diff())

        # 내부 상태
        self.all_results = []     # 원시 결과 리스트
        self.group_map = {}       # parent_iid -> (category, diff)

        # 레이아웃 리사이즈 허용
        master.grid_rowconfigure(5, weight=1)
        master.grid_columnconfigure(0, weight=1)

    def pick_path(self):
        path = filedialog.askdirectory()
        if path:
            current = self.path_text.get("1.0", tk.END).strip()
            if current:
                self.path_text.insert(tk.END, "\n" + path)
            else:
                self.path_text.insert(tk.END, path)

    def run_search(self):
        raw_paths = self.path_text.get("1.0", tk.END).splitlines()
        paths = [p.strip() for p in raw_paths if p.strip()]
        if not paths:
            messagebox.showerror("오류", "경로를 입력하세요")
            return

        # 정규식 검사
        cs_pattern_raw = self.cs_regex_var.get().strip()
        java_pattern_raw = self.java_regex_var.get().strip()
        try:
            re.compile(cs_pattern_raw)
            re.compile(java_pattern_raw)
        except re.error as e:
            messagebox.showerror("정규식 오류", f"정규표현식 컴파일 실패:\n{e}")
            return

        # 검색
        self.all_results = search_files(paths, cs_pattern_raw, java_pattern_raw)

        # 그룹화: (category, diff) -> set of (full_path, file_name, type)
        grouped = {}
        for full_path, file_name, ftype, category, diff in self.all_results:
            if self.type_filter.get() != "all" and self.type_filter.get() != ftype:
                continue
            key = (category, diff)
            grouped.setdefault(key, []).append((full_path, file_name, ftype))

        # GUI에 그리기 (트리: 부모 노드 = 그룹, 자식 = 파일)
        self.tree.delete(*self.tree.get_children())
        self.group_map.clear()

        for (category, diff), files in sorted(grouped.items(), key=lambda x: (x[0][0], x[0][1])):
            count = len(files)
            parent_text = f"{category}\t{diff}\t({count} files)"
            parent_iid = self.tree.insert("", tk.END, values=(parent_text, "", "", category, diff), open=False)
            self.group_map[parent_iid] = (category, diff)
            for full_path, file_name, ftype in sorted(files):
                self.tree.insert(parent_iid, tk.END, values=(full_path, file_name, ftype, "", ""))

        messagebox.showinfo("완료", f"{sum(len(v) for v in grouped.values())}개의 고유 그룹으로 검색완료 ({len(self.all_results)} raw matches).")

    def copy_category_diff(self):
        sel = self.tree.selection()
        if not sel:
            return
        to_copy = []
        seen = set()
        for iid in sel:
            cur = iid
            parent = self.tree.parent(cur)
            if parent == "":
                if cur in self.group_map:
                    key = self.group_map[cur]
                    if key not in seen:
                        to_copy.append(key)
                        seen.add(key)
            else:
                top = parent
                while self.tree.parent(top):
                    top = self.tree.parent(top)
                if top in self.group_map:
                    key = self.group_map[top]
                    if key not in seen:
                        to_copy.append(key)
                        seen.add(key)

        if not to_copy:
            return

        lines = []
        for category, diff in to_copy:
            lines.append(f"{category}\t{diff}")
        text = "\n".join(lines)
        try:
            self.master.clipboard_clear()
            self.master.clipboard_append(text)
            messagebox.showinfo("복사완료", "categoryCode and diffCode가 클립보드에 복사되었습니다.")
        except Exception:
            messagebox.showerror("오류", "클립보드 복사 실패")

    def save_excel(self):
        rows = []
        for parent in self.tree.get_children():
            vals = self.tree.item(parent, "values")
            category = vals[3]
            diff = vals[4]
            child_paths = []
            for child in self.tree.get_children(parent):
                cvals = self.tree.item(child, "values")
                child_paths.append(cvals[0])
            rows.append((category, diff, "; ".join(child_paths)))

        if not rows:
            messagebox.showinfo("저장취소", "저장할 데이터가 없습니다.")
            return

        save_path = filedialog.asksaveasfilename(defaultextension=".xlsx", filetypes=[("Excel 파일", "*.xlsx")])
        if not save_path:
            return

        try:
            wb = Workbook()
            ws = wb.active
            ws.append(["categoryCode", "diffCode", "file_paths_semi_colon"])
            for category, diff, paths_coll in rows:
                ws.append([category, diff, paths_coll])
            wb.save(save_path)
            messagebox.showinfo("완료", "엑셀 저장이 완료되었습니다.")
        except Exception as e:
            messagebox.showerror("오류", f"엑셀 저장 실패: {e}")


# 실행
if __name__ == "__main__":
    root = tk.Tk()
    app = App(root)
    root.mainloop()
